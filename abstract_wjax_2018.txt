
ACHTUNG: work in progress - bitte noch nicht kommentieren/editieren!!
ACHTUNG: work in progress - bitte noch nicht kommentieren/editieren!!
ACHTUNG: work in progress - bitte noch nicht kommentieren/editieren!!


Spieglein, Spieglein an der Wand...
Ein Vergleich der beiden JVM-Sprachen Groovy und Kotlin


Auf Basis der Java Virtual Machine hat sich in den letzten 20 Jahren eine große Zahl an alternativen Programmiersprachen
entwickelt. Diese Sprachen haben jeweils ihre eigene Syntax, werden aber in JVM-Bytecode übersetzt.
Damit können sie auf der ausgereiften und vielfach optimierten Java Virtual Machine ausgeführt werden.

In diesem Vortrag wollen wir zwei populäre derartige Sprachen betrachten und miteinander vergleichen:
Groovy und Kotlin.

Groovy wurde bereits ab 2003 entwickelt und hatte ursprünglich zum Ziel eine elegantere Syntax mit dynamischen Elementen zu verbinden.
Seit einigen Jahren wird Groovy unter dem Dach der Apache Software Foundation entwickelt,
was zu einem weiteren Anstieg der Downloadzahlen geführt hat.

Das Pojekt Kotlin wurde 2011 erstmalig vorgestellt, im Jahr 2016 erschien die Version 1.0.
Die Sprache wird von JetBrains entwickelt, vielen Java-Entwicklern bekannt als Hersteller der IDE Intellij.
Auch bei Kotlin wurden viele der im klassischen Java gefürchteten Pain Points angegangen.

Wir betrachten in diesem Vortrag Themen von allgemeinem Interesse wie Lizenzmodell und Java-Interoperabilität,
IDE-Support und mögliche Anwendungsgebiete (Android!).
Kotlin und Groovy spielen jeweils auch eine besondere Rolle bei Build Tools wie Gradle.


Beiden Sprachen ist gemein,
dass sie viele Sprachfeatures haben, die über die Möglichkeiten von Java hinausgehen.
Hier gibt es erstaunlich viele Gemeinsamkeiten zwischen beiden Sprachen,
aber durchaus auch signifikante Unterschiede.
Im Einzelnen wollen wir folgende Themen vergleichend betrachten:

- checked Exceptions
- Typisierung und Typinferenz, primitive Typen
- delegation
- Properties
- Data-Klassen
- Vererbung
- Erweiterung existierende Klassen, sogar von JDK-Klassen
- Nullsicherheit
- Funktionale Programmierung, insbesondere Higher Order-Functions und Komposition
- benannte und Default-Argumente
- (Literale) Syntax für Listen und Maps
- Operator Overloading

Immer wieder einen Blick in Richtung der Muttersprache Java werfen


// Tail Recursion, Coroutines...




